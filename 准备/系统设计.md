1. 概述

   1. 确认需求: 哪些功能, 最大需要承受的访问量
   2. 拆分服务: 每个服务下的功能
   3. 数据存储: 设计表结构

2. 短链接服务

   1. 概述
      1. 短链接到长链接的映射需要持久化
      2. 短码一般不超过8位

   2. 应用
      1. 缩短链接长度, 用于有限字数的分享
      2. 生成简明的二维码
   3. 访问http://a/c过程
      1. 通过DNS获得a域名的IP地址
      2. 向IP地址发送请求, 查询路径c
      3. 服务器会响应真实的地址, 并将状态码置为302(临时重定向)
      4. 浏览器根据重定向跳转到真实网址
   4. 301还是302
      1. 301是永久重定向, 302是临时重定向
      2. 由于短地址形成后不会改变, 使用永久重定向能减少服务器压力, 这符合HTTP的语义
      3. 但是永久重定向会使数据统计不准确且不利于撤销, 故建议使用临时重定向, 即302状态码
   5. 短链接向长链接的映射算法
      1. 摘要算法
         1. 使用非加密的murmurhash算法
         2. 摘要算法总是会产生冲突, 冲突后当然可以再进行摘要, 直到找到不冲突的短链接
      2. 发号器算法 (自增算法)
         1. 小型系统: MySQL的自增索引
         2. 中大型系统: Redis分片
   6. 映射算法的结果可以使用62进制(A-Za-z0-9), 缩减短链接的长度
   7. 持久化
      1. 存入数据库
         1. 库中无数据, 直接存入
         2. 库中有数据, 检查是否和长链接一致, 一致则返回, 不一致则进入冲突处理. 当映射算法为发号器自增算法时, 不会产生冲突
      2. 存入Redis
         1. key为长链接, val为短链接. 有的话过期时间重设, 没有的话就插入. 淘汰策略为LRU

3. 微信扫码登录

   1. 前端调起微信的页面, 传递app_id/app_secret

   2. 微信页面通过app_id/app_secre向微信服务器指定接口拿到二维码, 二维码的内容是http://微信登录接口?id=xxx
   3. 通过微信客户端扫描二维码访问登录接口, 微信服务器将微信客户端的用户与id相绑定, 此时微信客户端显示"是否登录", 微信前端页面会pending请求
   4. 微信客户端点击登录, 服务器立即返回pending的请求, 响应中带有登录用户的code
   5. 原网站获得code, 带着app_id与app_secert, 向微信服务器指定接口请求, 从而获得access_token, 从中解出用户的基本信息

4. 秒杀系统

   1. 问题

      1. 高并发: 100件商品, 100万流量. 缓存雪崩, 缓存击穿, 缓存穿透

      2. 一致性: 超卖
      3. 高可用
      4. 恶意请求: 链接提前暴露, 十几台机器模拟十几万人的请求
      5. 数据库: 十几万QPS

   2. 解决思路

      1. 高并发

         1. 提前预估流量, 秒杀商品提前报名

         2. 实时热点发现, 上游服务日志实时输入热点分析平台, 下游服务通过订阅, 预先准备数据

         3. CDN -> 缓存 -> 数据库, 将请求尽量拦截在上层, 避免数据库中读写锁频繁冲突

            根据是否是含有个性化数据拆分出静态数据, 动态数据. 静态数据放到cdn或统一的cache层中, 做到90%的请求都落在缓存中

         4. 限流

            1. 前端限流: 1) 点击一下, 按钮置灰几秒 2) 答题 3) 微信摇一摇
            2. 服务器限流

         5. 应用服务器异步化改造, 减少IO等待. 服务之间通过异步队列, 将请求排队, 削峰

         6. 请求所消耗的时间, 一部分用于CPU计算, 一部分用于各种IO等待

            1. 不断减小CPU计算时间
               1. 减少编码(字符与字节转化), 直接使用流输出
               2. 减少序列化(减少RPC即减少序列化, 减少序列化即减少编码)
            2. 等待时间不用管, 因为提升并发数, 就能进一步榨取CPU. 进程数=CPU核心数, 线程数=2*CPU核心数+1
            3. 当QPS已达到顶峰, 但CPU未到90%以上, 系统就仍可优化

      2. 超卖

         1. 扣库存的时机

            购买分为下单, 扣款两步, 减库存的方式考虑使用下单减库存. 不用扣款减库存是由于第三方支付存在扣款后已卖光的可能

         2. 如何防止超卖, 把库存放入Redis中, 用Redis的单线程来保障, 扣减库存使用Lua脚本

         3. 方式一

            1. 下单后在Redis中扣减库存, 异步写入MySQL

         4. 方式二

            1. 下单在Redis中锁定库存, 支付完成在数据库中减库存, 并落订单数据, 可防止订单已生成但无库存

      3. 高可用

         1. 服务单一职责
            2. 系统隔离: 独立的服务
            3. 数据隔离: 独立的缓存, 数据库
         2. 不要有单点
         3. 熔断/限流/降级
         4. 完善的监控: CPU, IO, RT, 缓存
         5. 崩溃后的策略: 下架商品

      4. 恶意请求

         1. URL动态化: 秒杀前隐藏秒杀链接, 秒杀后前端先访问服务器取得秒杀链接, 再通过该链接发起秒杀
         2. 验证码答题: 既可以防止秒杀器, 又将峰值下单请求降低了, 将峰值时间从1秒拉长到10秒. 

         3. 限制同用户购买次数, 通过Redis
         4. 限制同个IP的请求频率, 超过限制就进行验证码确认
         5. 用户画像筛选出真实用户 (比如微博的中奖用户是年轻的使用iPhone的女性)

      5. 数据库

         1. 库存预热, 秒杀前提前把商品加入Redis队列中
         2. 数据库连接池